%% \VignetteIndexEntry{Frequently Asked Questions}
%% \VignettePackage{CorporaCoCo}

\SweaveInput{common.tex}

\title{Frequently Asked Questions}

\begin{document}

\maketitle

\tableofcontents
<<label='load libraries', echo=FALSE>>=
library(CorporaCoCo)
library(stringi)
@

%% not allowed to have CorporaCorpus on CRAN until the world stops using dial up.
% <<>>=
% library(CorporaCorpus)
% GE  <- unlist( stri_extract_all_words( stri_trans_tolower( readLines(corpus_filepaths('DNov', 'GE')) ) ))
% TTC  <- unlist( stri_extract_all_words( stri_trans_tolower( readLines(corpus_filepaths('DNov', 'TTC')) ) ))
% nodes <- c('back', 'eye', 'eyes', 'forehead', 'hand', 'hands', 'head', 'shoulder')
% results <- surface_coco(TTC, GE, span = '5LR', nodes = nodes)
% @
<<label='load results set', echo=FALSE>>=
results <- readRDS('results_TTC_vs_GE.rds')
@

\tableofcontents

% ----------------------
% Co-occurrence counting
% ----------------------
\section{Co-occurrence}

\subsection{How do I count the co-occurrences for my corpora?}
The not very useful answer is ``however you like''.

More usefully to get you started we supply the \textCode{surface()} function which, given a vector of the tokenized corpus text, will produce a complete set of \textit{surface co-occurrence} hit and miss counts in the form expected by the \textCode{coco()} function.
<<label='Using the surface function'>>=
library(stringi)

text <- "‘One side of WHAT? The other side of WHAT?’ thought Alice to herself."
tokens <- unlist(stri_extract_all_words( stri_trans_tolower(text)))

surface(tokens, span = '2R')
@
If you are not sure about or need a reminder of the different types, and interpretations of, the various flavors of co-occurrence refer to \textcite{evert_corpora_2008}.

% Co-occurence barriers
\subsection{Does the package understand co-occurrence barriers?}
Yes, but if you are interested in co-occurrence barriers you should probably be using a more sophisticated tool for your co-occurrence counting than our \textCode{surface()} function.
That being said the \textCode{surface()} function does implement a basic idea of co-occurrence boundaries.
Any \textCode{NA} in the vector of tokens passed to the \textCode{surface()} function will be counted as a token when considering token seperation, but counts of co-occurrence with \textCode{NA} are ignored; the implication of this is that with a \textCode{span = n} any set of \textCode{n} consecutive \textCode{NA} elements will act as a co-occurrence boundary. For example using the \textCode{stringi} package to seperate sentences we can stop co-occurrence across sentence boundaries.
<<label='sentences co-occurrence boundaries'>>=
sentences  <- unlist(stri_extract_all_boundaries(text, type = 'sentence'))
sentences

span <- 2
tokenized_sentences <- stri_extract_all_words(stri_trans_tolower( sentences )) 
tokens <- unlist(lapply(tokenized_sentences, function(x) append(x, rep(NA, span))))
tokens

surface(tokens, span = '2R')
@


% -------
% Ploting
% -------

\section{Plotting results}
\subsection{How do I plot my results?}
Any object returned by the \textCode{coco()} or \textCode{surface\_coco()} functions can be plotted
directly. For example here is how you would plot the results from the `Proof of Concept' vignette.
<<fig = TRUE>>=
plot(results)
@

Also remember that the \textCode{results} object is just a \textCode{data.frame} so you can fashion
your own plots directly from the data.

\subsection{How do I plot a subset of my results?}
The object returned by the \textCode{coco()} and \textCode{surface\_coco()} functions is a
\textCode{coco} object. When you \textCode{plot()} a \textCode{coco} object you can pass
an optional \textCode{nodes} argument, this can be used to both filter the results set
on nodes and to control the order of the nodes in the plot. 
For example if you only wanted to plot results for the "eyes", "hand", "back" nodes and
you wanted to plot them out of alphabetical order
<<fig = TRUE>>=
plot(results, nodes = c('eyes', 'hand', 'back'))
@

Also remember that the object returned by the \textCode{coco()} and \textCode{surface\_coco()} functions
is also just an ordinary \textCode{data.frame} so you can filter and order it just like you would any other
\textCode{data.frame}.
This is useful if you want to do some more complex filtering of your results, for example if you are only
interested in results with a positive effect size
<<fig = TRUE>>=
plot( with(results, results[effect_size > 0]) )
@

\subsection{How do I control what the plot looks like?}
When plotting a \textCode{coco} object object there are a limited set of arguments that you
can pass through to the underlying \textCode{plot} function; these are listed in the help for
\textCode{plot.coco()}.
They can be used something like this
<<fig = TRUE>>=
plot(
    with(results, results[effect_size > 0]),
    forest_plot_args = list(
        main = 'Co-occurrences with a positive effect size',
        xlim = c(-2, 10),
        xlab = 'Effect Size (log of the odds ratio)'
    )
)
@

Also any graphical parameters set using \textCode{par()} will also effect the plot.
By combining the two you can effect most of the visual aspects of the plot, for example
<<fig = TRUE>>=
keep <- par(no.readonly=TRUE)
par(
    cex.main = 1.5,
    col.main = 'blue',
    cex.axis = 1.5,
    col.axis = 'purple',
    cex.lab = 1.5,
    col.lab = 'darkgreen',
    lwd = 3.0,
    col = 'darkred'
)

plot(
    with(results, results[effect_size > 0]),
    forest_plot_args = list(
        main = 'Co-occurrences (positive effect size)',
        xlim = c(-2, 10),
        xlab = 'Effect Size (log of the odds ratio)',
        pch = 17,
        cex.pch = 2,
        lwd.xaxt = 2.0,
        col.xaxt = 'darkcyan',
        col.whisker = 'red',
        col.zero = 'darkorange'
    )
)

par(keep)
@

%% bibliography
\clearpage
\addcontentsline{toc}{section}{Bibliography}
\printbibliography

\end{document}
